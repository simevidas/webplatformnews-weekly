1. **The goal of the Accessibility Object Model (AOM)**

   Form controls (`<input>`, `<select>`, etc.) can only be styled to a certain degree in browsers, so some web apps re-implement them with HTML and CSS. In order to make these custom implementations accessible, ARIA attributes have to be used, which isnâ€™t ideal, because it requires writing to the DOM repeatedly, and using `id` attributes with unique values to declare relationships between elements. The Accessibility Object Model is an upcoming JavaScript API that aims to make this easier, by allowing web apps to define an elementâ€™s semantics via a `this.accessibleNode` object instead of ARIA attributes.

   â¥ [Article](http://robdodson.me/the-future-of-accessibility-for-custom-elements/) [ğŸ’¬](https://twitter.com/rob_dodson/status/914960465335246848) &bull; [AOM repository](https://github.com/wicg/aom) &bull; [Chromiumâ€™s implementation](https://bugs.chromium.org/p/chromium/issues/detail?id=680345)

1. **[webpagetest.org/easy](https://webpagetest.org/easy)**

   On WebPageTestâ€™s website, the `/easy` path loads the useful â€œSimple Testingâ€ interface, which defaults to a â€œMobile - Emerging Marketsâ€ profile (it uses a connection that is even slower than â€œslow 3Gâ€), and includes a checkbox for running Chromeâ€™s Lighthouse audit (normally located in the â€œChromeâ€ tab of the advanced settings).
   
   â¥ [Discussion](https://twitter.com/justmarkup/status/918420911547670528)

1. **Animating blur is not efficient**

   Animating the CSS `filter: blur()` value should be avoided, because itâ€™s not efficient. The problem is that the CSS animation â€œpromotesâ€ the element, which in turn causes the (â€œinherently expensiveâ€) blur effect to be applied by the GPU *every frame*, blowing the 16-ms frame budget. For this same reason, animating a blurred element (e.g. its `opacity`) is inefficient in general. However, an efficient blur animation can be emulated via a hack that involves creating multiple versions of the element at different blur stages (different `blur()` values), and then cross-fading between them, by animating the `opacity` value of their parent elements. (The wrappers are needed to prevent the blurred elements from getting promoted.)

   â¥ [Article](https://developers.google.com/web/updates/2017/10/animated-blur) [ğŸ’¬](https://twitter.com/DasSurma/status/918478661136855047)
